## [3.1] 운영체제의 큰 그림

운영체제는 특별한 프로그램이다. 대표적으로 우리가 흔히 알고 있는 윈도우와 맥OS, 리눅스는 데스크탑의 운영체제이고, 안드로이드와 iOS는 스마트폰의 운영체제이다.
방대한 프로그램인 만큼, 운영체제에는 매우 많은 종류와 다양한 기능이 있다.
다만, 스마트폰의 경우에도 종류는 매우 다양하지만 전화 통화나 문자 메시지, 인터넷 접속과 같은 핵심 서비스는 종류를 막론하고 비슷한 것처럼, 운영체제 또한 종류에 관계 없이 운영체제가 제공하는
**핵심적인 기능**은 비슷하다.

<img src="https://github.com/user-attachments/assets/b49aabab-5c87-40cb-b65c-5da5318e7113" width="380"/><br/>

이러한 운영체제의 핵심 기능을 담당하는 부분을 **커널(kernel)** 이라고 한다. 커널은 마치 자동차의 엔진이나 사람의 심장과도 같은 핵심부라고 할 수 있다.
특별한 언급이 없다면 이번 장에서 설명하는 '운영체제'라는 용어는 '커널'을 지칭한다고 이해하면 된다.

<img src="https://github.com/user-attachments/assets/ab6c4420-d25b-4d6c-9dd4-d79c6a525e10" width="370"/>
<br/>
<br/>
운영체제에는 크게 2가지의 핵심 기능이 있다. 하나는 자원 할당 및 관리이고, 또 하나는 프로세스 및 스레드 관리이다.
먼저 2가지 핵심 기능을 정리하고, 프로그램들이 운영체제의 기능을 제공받는 방법을 살펴보면서 운영체제의 큰 그림을 그려 볼 것이다.
<br/>
<br/>
<img src="https://github.com/user-attachments/assets/d708750b-7324-43b9-bab7-6178d641d41b" width="380"/><br/>
<br/>

### 🍓 운영체제의 역할
운영체제의 핵심 기능인 '자원 할당 및 관리'에 대해 알아보기 위해서는 우선 자원이 무엇인지부터 이해해야 한다.
**자원(resource)** (혹은 **시스템 자원(system resource)**)이란 프로그램 실행에 마땅히 필요한 요소를 의미한다.
실행에 필요한 '데이터'를 자원(소프트웨어)이라고 하기도 하고, 실행에 필요한 '부품'을 자원(하드웨어)이라고 하기도 한다. 앞서 학습한 컴퓨터의 핵심 부품을 대표적인 자원으로 꼽을 수 있다.

운영체제는 사용자가 실행하는 응용 프로그램을 대신하여 CPU, 메모리, 보조기억장치 등의 컴퓨터 부품에 접근하고, 각각의 부품들이 효율적으로 사용되도록 관리한다.
또 응용 프로그램이 컴퓨터 부품들을 효율적으로 할당받아 문제 없이 실행할 수 있도록 응용 프로그램에게 자원을 할당한다.
이번 장에서는 운영체제가 컴퓨터 구조에서 학습한 CPU, 메모리, 보조기억장치를 어떻게 관리하는지 위주로 학습해 보겠다.

#### [CPU 관리 : CPU 스케줄링]
메모리에는 실행 중인 프로그램이 다수 적재될 수 있지만, CPU가 이들 모두를 동시에 실행할 수 있는 것은 아니다.
CPU는 한정된 자원이기 때문에 CPU를 할당받아 사용하기 위해 때로는 다른 프로그램의 CPU 사용이 끝날 때까지 기다려야 한다.
그래서 운영체제는 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 CPU의 할당 순서와 사용 기간을 결정한다. 이것이 바로 CPU 스케줄링이다.

<img src="https://github.com/user-attachments/assets/dc8f7785-0912-4655-a813-fad64dd694b0" width="470"/><br/>
<br/>

#### [메모리 관리 : 가상 메모리]
또한 운영체제는 새롭게 실행하는 프로그램을 메모리에 적재하고, 종료된 프로그램을 메모리에서 삭제한다. 동시에 낭비되는 메모리 용량이 없도록 효율적으로 관리한다.
오늘날 존재하는 많은 운영체제들은 이를 위해 가상 메모리 기술을 활용한다. '가상 메모리'는 운영체제의 메모리 관리 기법 중 하나로, 실제 물리적인 메모리 크기보다 더 큰 메모리를 이용할 수 있도록 하는 기술이다.

<img src="https://github.com/user-attachments/assets/d0d680b9-cf50-400c-b917-021c31bf8308" width="350"/><br/>
<br/>

#### [파일/디렉터리 관리 : 파일 시스템]
메모리보다 더 큰 용량을 갖고 있는 보조기억장치는 더욱 일목요연하게 관리할 필요가 있다.
보조기억장치에 아무렇게나 정보를 저장한다면 마치 어질러진 서랍에서 원하는 물건을 찾듯 원하는 정보에 접근하기 위해 오랜 시간이 소요되기 때문이다.
운영체제는 보조기억장치를 효율적으로 관리하기 위해 파일 시스템을 활용한다. 파일 시스템은 보조기억장치 내의 정보를 파일 및 폴더(디렉터리) 단위로 접근・관리할 수 있도록 만드는 운영체제 내부 프로그램이다.

<img src="https://github.com/user-attachments/assets/d4696222-f592-40ce-9dad-2f5bf4f1f77f" width="320"/><br/>

> #### 운영체제의 입출력장치 및 캐시 메모리 관리
> 앞서 우리는 컴퓨터의 핵심 부품인 CPU, 메모리, 보조기억장치 외에 입출력장치와 캐시 메모리도 다뤘다. 이들 또한 운영체제에 의해 관리되는 자원이다.
> 운영체제는 일부 입출력장치의 장치 드라이버, 하드웨어 인터럽트 서비스 루틴을 제공하거나 캐시 메모리의 일관성을 유지하는 등의 기능을 제공한다.
<br/>

#### [프로세스 및 스레드 관리]
지금까지 우리가 단순히 '실행 중인 프로그램'이라고 지칭했던 대상은 **프로세스(process)** 라고 한다. 그리고 **스레드(thread)** 는 이 프로세스를 이루는 실행의 단위이다.
메모리에는 여러 프로세스가 적재될 수 있는데, 운영체제는 이 프로세스에 필요한 자원을 할당하고, 스레드는 프로세스가 할당받은 자원을 이용해 프로세스의 작업을 수행한다.
프로세스를 이루는 스레드가 둘 이상인 경우에는 동일한 작업을 동시에 실행할 수도 있다.

<img src="https://github.com/user-attachments/assets/123bd36b-b0fa-4324-940c-9ff3681e9941" width="450"/><br/>

> 같은 프로그램이라도 여러 번 실행하면 별도의 프로세스가 될 수 있다.

운영체제는 이렇게 동시다발적으로 실행되는 프로세스와 스레드가 올바르게 처리되도록 실행의 순서를 제어하고, 프로세스와 스레드가 요구하는 자원을 적절하게 배분할 수 있어야 한다.
이와 관련하여 운영체제가 프로세스와 스레드를 어떻게 다루는지, 프로세스와 스레드를 동시에 실행하는 환경에서는 어떤 문제를 고려해야 하는지 차례로 학습해보자.

<img src="https://github.com/user-attachments/assets/eca9cf55-f445-4729-a22b-8ccaec0dbaa3" width="280"/><br/>
<br/>

### 🍓 운영체제 지도 그리기
운영체제의 역할(핵심 기능)을 바탕으로 한눈에 정리된 운영체제 지도를 보면서 학습의 흐름을 정리해 보기 바란다.

<img src="https://github.com/user-attachments/assets/3302ea43-a9dd-4737-bfff-b13db3f9a99a" width="680"/><br/>
<br/>

### 🍓 시스템 콜과 이중 모드
운영체제도 일종의 프로그램이기 때문에 프로그램이 실행되기 위해서는 반드시 메모리에 적재되어 있어야 한다.
다만, 사용자 프로그램과는 달리 운영체제는 매우 특별한 프로그램이므로 메모리 내의 **커널 영역(kernel space)** 이라는 공간에 따로 적재되어 실행된다.
다음과 같이 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간은 **사용자 영역(user space)** 이라고 한다.
우리가 주목할 점은 '운영체제의 기능을 제공받기 위해서는 커널 영역에 적재된 운영체제 코드를 실행해야 한다'는 점이다.

<img src="https://github.com/user-attachments/assets/2a2ec5ef-5870-4ce7-89c9-c40c05c504d4" width="230"/><br/>
<br/>

일반적으로 웹 브라우저나 게임과 같은 (사용자)응용 프로그램은 운영체제와 달리 CPU, 메모리와 같은 자원에 직접 접근하거나 조작할 수 없다. 특정 자원에 접근하거나 조작하는 운영체제 코드를 실행해야 한다.
즉, 운영체제가 자신의 코드를 실행한 응용 프로그램의 자원 접근 및 조작을 대행하는 셈이다.

그렇다면 응용 프로그램은 어떻게 운영체제의 코드를 실행할 수 있을까? 응용 프로그램은 **시스템 콜(system call)** 을 호출하여 운영체제 코드를 실행할 수 있다.
시스템 콜은 운영체제의 서비스를 제공받기 위한 수단(인터페이스)으로, 호출 가능한 함수의 형태를 가진다.
응용 프로그램이 운영체제로부터 어떤 기능을 제공받고자 한다면 다음과 같이 그 기능에 해당하는 시스템 콜을 호출하면 된다.

<img src="https://github.com/user-attachments/assets/b3276c3b-c5a4-4538-a320-934051114e29" width="550"/><br/>
<br/>

운영체제에 따라 제공하는 시스템 콜의 종류와 개수는 다양하다. 다음은 유닉스 계열의 운영체제에서 사용하는 대표적인 시스템 콜의 종류이다.
암기할 필요는 없지만, 응용 프로그램들은 내부적으로 다음과 같은 형태의 시스템 콜을 호출하여 운영체제의 기능을 제공받는다는 점을 기억하자.

<img src="https://github.com/user-attachments/assets/6e7cc329-8875-4f2c-ab3f-fc15b44e25b7" width="620"/>
<img src="https://github.com/user-attachments/assets/119988c5-be8f-4b94-bb87-56363d744221" width="620"/>

> #### 프로세스의 계층 구조
> 제시된 표의 fork() 시스템 콜을 통해 알 수 있듯 프로세스는 시스템 콜을 통해 또 다른 프로세스를 생성하고, 그렇게 생성된 프로세스는 또 다른 프로세스를 생성할 수 있다.
> 많은 운영체제에서 프로세스들은 이렇게 계층적으로 관리된다.
> 이때 새 프로세스를 생성한 프로세스를 **부모 프로세스(parent process)**, 부모 프로세스에 의해 생성된 프로세스를 **자식 프로세스(child process)** 라고 한다.
>
> <img src="https://github.com/user-attachments/assets/8d6bd33f-c502-4448-ab11-1c274aade4d0" width="500"/><br/>

컴퓨터 내부에서 시스템 콜이 호출되면 다음과 같은 작업이 수행된다. 여기서 핵심은 소프트웨어 인터럽트와 커널 모드, 사용자 모드이다.
<br/>
<br/>
<img src="https://github.com/user-attachments/assets/74654e8b-9059-40d6-9bf9-f63a667c8bcb" width="630"/><br/>

운영체제에는 인터럽트를 발생시키는 특정 명령어가 있다. 자원에 접근하는 입출력 명령어가 대표적이며, 이러한 명령어에 의해 발생하는 인터럽트를 **소프트웨어 인터럽트(software interrupt)** 라고 한다.

시스템 콜이 바로 이 소프트웨어 인터럽트의 일종이다.
따라서 [1] 사용자 영역을 실행하는 과정에서 시스템 콜이 호출되면 여느 인터럽트와 마찬가지로 CPU는 현재 수행 중인 작업을 백업하고, [2] 커널 영역 내의 인터럽트를 처리하기 위한 코드(시스템 콜을
구성하는 코드)를 실행한 뒤, [3] 다시 사용자 영역의 코드 실행을 재개한다.

<img src="https://github.com/user-attachments/assets/456f83d9-2597-4e6f-bf9a-441863ce662f" width="400"/><br/>
<br/>

또 CPU는 명령어를 실행하는 과정에서 사용자 영역을 실행할 때의 모드와 커널 영역을 실행할 때의 모드를 구분하여 실행한다.
이때 사용자 영역에 적재된 코드를 실행할 때의 모드를 **사용자 모드(user mode)** 라 하고, 커널 영역에 적재된 코드를 실행할 때의 실행 모드를 **커널 모드(kernel mode)** 라 한다.
그리고 이렇게 2개의 모드로 구분하여 실행하는 것을 **이중 모드(dual mode)** 라고 한다.

> CPU가 사용자 모드로 실행 중인지, 커널 모드로 실행 중인지는 플래그 레지스터 속 슈퍼바이저 플래그를 보면 알 수 있다.
> 플래그 레지스터의 슈퍼바이저 플래그는 '플래그의 종류'(p68)를 나타낸 표에서 참고할 수 있다.

**사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행 모드**로, 커널 영역의 코드를 실행할 수 없는 모드이다.
사용자 모드로 실행 중인 CPU는 입출력 명령어와 같이 자원에 접근하는 명령어를 만나도 이를 실행하지 않는다. 덕분에 사용자 모드로 실행되는 명령어는 실수로라도 자원에 접근할 수 없다.
반면, **커널 모드는 운영체제 서비스를 제공받을 수 있는 실행 모드**로, 커널 영역의 코드를 실행할 수 있는 모드이다.
CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있다. 운영체제는 이 커널 모드로 실행되기 때문에 자원에 접근할 수 있는 것이다.

응용 프로그램은 실행 과정에서 시스템 콜을 매우 빈번하게 호출한다.
단적인 예로, 다음과 같이 화면에 "hello world"라는 문자열을 출력하는 단순한 프로그램조차 실행 과정에서 무려 600회가 넘는 시스템 콜을 호출한다.

<img src="https://github.com/user-attachments/assets/0ed53e13-6fca-45ca-ac31-6836a5c867b4" width="500"/><br/>
<br/>
소스 코드로 작성된 프로그램뿐만 아니라 ls와 같은 명령어 또한 프로그램이기 때문에 마찬가지로 실행 과정에서 수많은 시스템 콜을 흐출한다.
이처럼 프로그램은 시스템 콜을 통해 사용자 모드와 커널 모드를 빈번히 오가며 운영체제의 소스 코드를 실행한다.

<img src="https://github.com/user-attachments/assets/6b71b1d7-862a-40fb-a5c8-35a4e28c5ce0" width="500"/><br/>

> 제시된 결과는 strace라는 도구를 사용해 출력하였다. strace는 리눅스 운영체제에서 시스템 콜을 추적 관찰하는 도구이다.