## [5.3] 네트워크 계층 - IP

물리 계층과 데이터 링크 계층에 속한 기술은 대부분 LAN을 위한 기술이다. 하지만 같은 LAN에 속한 호스트끼리만 통신을 주고받는 것은 아니다.
LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요하다.
여기서 특히 중요하게 사용되는 기술이 네트워크 계층의 가장 핵심적인 프로토콜이라고 할 수 있는 IP(Internet Protocol)이다.
이번 절에서는 IP를 중심으로 네트워크 간의 통신이 이루어지는 방법을 알아보겠다.
<br/>
<br/>
### 🍓 IP의 목적과 특징
IP에 관해 가장 먼저 알아야 할 것은 IP의 목적과 특징이다. IP의 본래 목적은 크게 **주소 지정(addressing)** 과 **단편화(fragmentation)**, 2가지로 나뉜다.
주소 지정은 네트워크 간의 통신 과정에서 호스트를 특정하는 것을 의미하고, 단편화는 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것을 의미한다.
또한 IP는 '신뢰할 수 없는 통신'과 '비연결형 통신'이라는 중요한 특징을 갖고 있다.
IP의 목적과 특징은 뒤이어 학습할 IP 주소의 개념과 구조, 나아가 전송 계층의 목적 등을 이해하는 데 필요한 내용이므로 하나씩 살펴보자.
<br/>

#### [주소 지정과 단편화]
우선 주소 지정에 대해 알아보자. 주소 지정은 **IP 주소**를 통해 이루어지며, 이는 IP 패킷 헤더를 통해 알 수 있다. 다음은 IP 패킷 헤더와 페이로드(일부)를 나타낸 그림이다.
모든 항목을 하나하나 학습하기보다는 IP의 목적과 특징을 기준으로 중요한 필드를 살펴보겠다. 우선 IP의 주소 지정과 관련한 필드를 확인해보자. **송신지 IP 주소**와 **수신지 IP 주소** 필드이다.
두 필드에는 송수신지를 식별할 수 있는 IP 주소가 명시된다.

<img src="https://github.com/user-attachments/assets/c619fd28-0737-41f7-a4d4-7367a209e4a8" width="470"/><br/>

하나의 IP 주소는 총 4바이트(32비트)의 크기로 구성되고, 숫자당 8비트로 표현되므로 0 ~ 255 범위의 10진수 4개로 표기된다.
각각의 10진수는 점(.)으로 구분하는데, 여기서 점으로 구분된 하나의 10진수를 **옥텟(octet)** 이라고 한다.
가령 '102.168.0.1'이라는 IP 주소가 있다면 '192', '168', '0', '1' 각각이 8비트로 표현 가능한 옥텟인 셈이다.

> 참고로, 오늘날의 IP는 IP 버전 4(이하 IPv4)와 버전 6(이하 IPv6), 2가지 종류가 있다.
> 둘 중 더 빈번히 사용되는 버전이 IPv4이므로 특별한 언급이 없는 한 이후에 등장하는' IP'라는 용어는 'IPv4'를 지칭하는 것으로 설명한다.

MAC 주소는 택배 배송 과정의 수신인과 발신인, IP 주소는 수신 주소와 발신 주소에 빗댈 수 있다.
택배를 제대로 배송하기 위해 수신인과 발신인의 정보, 그리고 수신 주소와 발신 주소의 정보가 모두 필요하듯, 패킷을 올바르게 전송하기 위해서는 MAC 주소와 IP 주소가 모두 필요하다.
또한 택배 배송 기사가 배송 과정에서 수신인과 발신인의 정보보다는 수신 주소와 발신 주소를 우선적으로 활용하듯, 패킷의 송수신 과정에서도 MAC 주소보다는 IP 주소가 우선적으로 활용된다.

서로 다른 네트워크에 속한 두 호스트가 네트워크 간 통신을 수행할 때, IP 주소를 바탕으로 목적지까지 IP 패킷을 전달하는 네트워크 장비로 **라우터(router)** 가 있다.
라우터는 네트워크 계층에 속한 핵심 장비로, 전달받은 패킷을 목적지까지 전달하는 역할을 수행한다.
이때 라우터는 IP 패킷을 전달할 최적의 경로를 결정하고 해당 경로로 패킷을 내보낼 수 있어야 하는데, 이 과정을 **라우팅(routing)** 이라고 한다.
즉, 라우터는 IP 주소를 기반으로 패킷의 최적 경로를 결정하여 목적지까지 전달(라우팅)하는 네트워크 장비이다. 우리가 흔히 알고 있는 공유기도 라우팅을 수행할 수 있으므로 라우터의 일종이라고 볼 수 있다.

<img src="https://github.com/user-attachments/assets/7d28ff1c-deed-43a3-8952-b0839e468b50" width="450"/>

> #### IPv6
> 하나의 IP(IPv4) 주소는 총 32비트로 표현된다. 따라서 이론적으로 할당 가능한 IPv4 주소는 총 2^32개, 약 43억 개이다.
> 이는 전 세계 인구가 IP 주소를 하나씩만 가지고 있어도 부족한 숫자이므로 IPv4 주소는 고갈될 여지가 있다. 그래서 등장한 프로토콜이 IPv6이다.
> IPv6 기반의 주소 체계인 IPv6 주소는 16바이트(128비트)로 주소를 표현할 수 있기 때문에 이론적으로 할당 가능한 IPv6 주소는 사실상 무한에 가까운 수인 2^128개가 된다.
> IPv4 주소와 달리, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기된다.
>
> <img src="https://github.com/user-attachments/assets/16cb6652-1d40-4e7e-b6f1-1c15cfc7f2c5" width="600"/><br/>

다음은 IP의 단편화 관련 기능이다. IP 단편화를 이해하려면 MTU라는 단위를 먼저 이해해야 한다. **MTU(Maximum Transmission Unit)** 은 말 그대로 최대 전송 단위를 의미한다.
전송하고자 하는 IP 패킷(IP 헤더와 페이로드)의 크기가 MTU라는 단위보다 클 경우에는 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합된다.

일반적인 MTU 크기는 1500바이트이다.
앞서 프레임에 실릴 수 있는 최대 데이터의 크기가 일반적으로 1500바이트라고 언급했는데, 따라서 MTU는 프레임을 통해 주고받을 수 있는 최대 페이로드의 크기라고 보아도 무방하다.

<img src="https://github.com/user-attachments/assets/21097158-b654-4a48-ad4e-9515eea11aaa" width="720"/><br/>

IP 패킷 헤더에서 단편화와 관련된 필드는 식별자, 플래그, 단편화 오프셋이다. 복잡해 보이지만 하나씩 살펴보면 어렵지 않다. 다음과 같이 간단하게 정리해 보겠다.

- [1] **식별자(identifier)** : 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드이다.
  같은 정보에서 쪼개진 패킷들은 같은 식별자를 공유하기 때문에 식별자를 통해 단편화되어 전송되는 패킷을 구분할 수 있다.

- [2] **플래그(flag)** : 3비트로 구성된 필드로, 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF라는 이름이 붙어 있다.
  첫 번째 비트는 항상 0으로 설정되어 오늘날 사용되지 않고, DF는 'IP 단편화를 수행하지 말라(Don`t Fragment)', MF는 '단편화된 패킷이 더 있다(More Fragment)'는 표시를 남기기 위한 비트이다.

  <img src="https://github.com/user-attachments/assets/3f6fc6d4-f914-4f74-9131-c449ddf423f0" width="550"/><br/>

- [3] **단편화 오프셋(fragment offset)** : 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드로, 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를
  나타내는 데 사용된다.

#### [신뢰할 수 없는 통신과 비연결형 통신]
IP는 신뢰할 수 없는 프로토콜이자, 비연결형 프르토콜이라고 이야기한다. 이러한 IP의 특징은 전송 계층의 주요 프로토콜인 TCP와 UDP의 존재 목적과도 직결된다.
**신뢰할 수 없는 프로토콜(unreliable protocol)** 이란 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜을 의미한다.
패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는 것을 의미한다.
신뢰할 수 없는 프로토콜의 송수신은 신뢰할 수 없는 통신, 신뢰성이 낮은 통신 혹은 **최선형 전달(best effort delivery)** 이라고 부른다.
최선형 전달이라는 단어가 오히려 신뢰성이 높은 전송을 의미하는 것처럼 보일 수 있지만, 실은 어떠한 보장도 하지 않는 전송 특징임을 유의하기 바란다.

IP는 **비연결형 프로토콜(connectionless protocol)** 이기도 하다. 이는 패킷을 주고받기 전에 사전 연결 과정을 거치지 않는다는 것을 나타낸다.
따라서 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 그저 패킷을 전송할 뿐이다. 반면, 패킷을 주고받기 전에 송수신지 간의 연결을 맺는 프로토콜이 있다. 다음 절에서 학습할 TCP가 대표적이다.
TCP는 송수신지 간의 연결 설정을 통해 패킷을 주고받을 호스트 간에 송수신 준비가 되었는지를 확인할 수 있다.

이러한 IP의 목적과 특성에 해당하는 실제 IP 패킷을 관찰해 보자.
다음 그림의 Src(Source Address), Dst(Destination Address)를 통해 송신지 주소는 '10.0.0.1'이고, 수신지 주소는 '10.0.0.2'라는 것을 알 수 있다.
식별자(Identification)는 '0x2c2e', 단편화 오프셋(fragment offset)은 '0'이고, 플래그(Flags) 필드에는 'More Fragments' 비트가 활성화되어 있다는 것도 확인할 수 있다.
즉, 이 IP 패킷을 이어 또 다른 단편화된 패킷이 존재한다는 것이다.

<img src="https://github.com/user-attachments/assets/80e04b0d-4c95-4a99-bffd-36c72712a2ea" width="700"/><br/>

또 다른 IP 패킷도 살펴보자. Identification은 '0x2c2e'이고, fragment offset은 '1480'이다.
즉, 이 패킷은 앞서 살펴본 패킷과 같은 데이터가 단편화된 것으로, '1480'만큼 떨어진 데이터가 단편화된 패킷이다.

<img src="https://github.com/user-attachments/assets/451b6715-683c-4c6c-a86a-a40d29d07c75" width="700"/><br/>

> #### IP 단편화 피하기 - 경로 MTU 발견
> IP의 본래 목적은 주소 지정과 단편화지만, 사실 오늘날의 네트워크 환경에서는 IP 단편화가 잘 발생하지 않는다.
> 단편화가 필요하지 않을 만큼 네트워크 성능이 발전하기도 했고, 무엇보다 IP 단편화가 되도록이면 발생하지 않는 것이 좋기 때문이다. 잦은 IP 단편화는 네트워크에 여러 악영향을 미칠 수 있다.
> 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아지기 때문에 불필요한 트래픽 증가와 대역폭 낭비를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있다.
>
> IP 단편화를 피하려면 IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 '처리 가능한 MTU 크기'를 고려해야 한다. 'IP 단편화 없이 주고받을 수 있는 최대 크기'만큼만 전송해야 한다.
> 이 크기를 **경로 MTU(Path MTU)** 라고 한다. 다음 그림의 경로 MTU는 1000바이트인 셈이다. 호스트가 1500바이트씩 주고받을 수 있더라도 단편화를 피하려면 1000바이트씩 주고받아야 하는 것이다.
>
> <img src="https://github.com/user-attachments/assets/6a961d4e-bece-4990-a4cf-4e2441a73c5f" width="380"/><br/>
>
> 이렇게 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술을 **경로 MTU 발견(Path MTU discovery)** 이라고 한다.
> 오늘날의 네트워크에서는 대부분 경로 MTU 발견을 지원하고, 처리 가능한 최대 MTU 크기도 균일하기 때문에 IP 단편화가 자주 발생하지 않는다.<br/>
<br/>

### 🍓 IP 주소의 구조
IP의 주요 목적인 주소 지정의 수단인 'IP 주소'는 중요한 개념이므로 좀 더 자세히 짚어 볼 필요가 있다. 네트워크 계층은 LAN 간의 통신을 가능하게 하고, 이는 IP 주소를 기반으로 이루어진다.
하나의 IP 주소는 0 ~ 255 범위의 10진수 4개(32비트)로 표기되는 IP주소는 크게 '네트워크 주소'와 '호스트 주소'로 이루어져 있다.
네트워크 주소는 네트워크 ID, 네트워크 식별자 등으로 불리며, 호스트가 속한 네트워크를 특정하기 위해 사용된다.
그리고 호스트 주소는 호스트ID, **호스트 식별자(host identifier)** 등으로 불리며, 네트워크에 속한 호스트를 특정하기 위해 사용된다.

<img src="https://github.com/user-attachments/assets/b30c0691-f1b3-427e-82df-47cd1247a866" width="300"/><br/>

중요한 점은 하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기가 유동적일 수 있다는 점이다.
이를 테면 다음 그림의 (a)처럼 네트워크 주소의 공간을 작게, 호스트 주소의 공간을 크게 표현할 수도 있고, (c)처럼 네트워크 주소의 공간을 크게, 호스트 주소의 공간을 작게 표현할 수도 있다.

<img src="https://github.com/user-attachments/assets/ccb436ab-ed33-4c8f-97e3-f0e08b936cb3" width="340"/><br/>

(a)의 경우는 호스트 주소에 24비트를 사용할 수 있기 때문에 상대적으로 네트워크당 많은 호스트에 IP 주소를 할당할 수 있는 반면, (c)의 경우는 호스트 주소에 8비트를 사용할 수 있기 때문에 상대적으로
네트워크당 적은 호스트에 IP 주소를 할당할 수 있다.
<br/>
#### [클래스풀 주소 체계]
IP 주소에서 네트워크 주소와 호스트 주소를 구분하는 범위가 유동적일 수 있다면 네트워크 주소와 호스트 주소의 크기는 각각 어느 정도가 적당할까? 답은 '상황에 따라 다르다'이다.
호스트 주소의 공간을 너무 크게 할당하면 호스트가 할당되지 않은 다수의 IP 주소가 낭비될 수 있고, 호스트 주소의 공간을 너무 작게 할당하면 호스트가 사용할 IP 주소가 부족해질 수 있다.
이러한 고민을 해결하기 위해 생겨난 개념이 바로 IP 주소의 **클래스(class)** 이다.

클래스는 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준이다. 어떤 클래스에 속한 IP 주소인지를 알면 IP 주소에서 네트워크 부분과 호스트 부분이 어느 정도의 크기인지 알 수 있다.
클래스는 A, B, C, D, E, 총 5개 종류가 있다.
이 중 D와 E 클래스는 각각 멀티캐스트를 위한 클래스로, 특수한 목적을 위해 예약된 클래스이기 때문에 네트워크의 크기별로 IP 주소를 분류하는 데 실질적으로 사용되는 클래스는 A, B, C이다.
이러한 클래스를 바탕으로 IP 주소를 관리하는 주소 체계를 **클래스풀 주소 체계(classful addressing)** 라고 한다.

그럼 네트워크의 크기를 나누는 A, B, C 클래스에 대해 좀 더 알아보자. 다음과 같이 A 클래스의 네트워크 주소는 비트 '0'으로 시작해 1옥텟으로 구성되며, 호스트 주소는 3옥텟으로 구성된다.
상대적으로 가장 많은 호스트를 할당할 수 있는 클래스이다. B 클래스의 네트워크 주소는 비트 '10'으로 시작해 2옥텟으로 구성되고, 호스트 주소도 2옥텟으로 구성된다.
C 클래스의 네트워크 주소는 비트 '110'으로 시작해 3옥텟으로 구성되며, 호스트 주소는 1옥텟으로 구성된다.

<img src="https://github.com/user-attachments/assets/074a5628-8c2b-46ee-a8ee-87d2406ee94a" width="380"/><br/>

클래스별 IP 주소 표현의 가능 범위는 다음과 같다.

- A 클래스: 0.0.0.0 ~ 127.255.255.255
- B 클래스: 128.0.0.0 ~ 191.255.255.255
- C 클래스: 192.0.0.0 ~ 223.255.255.255

클래스별 IP 주소 표현의 가능 범위를 보면 알 수 있듯, 첫 옥텟의 주소만 보고도 A, B, C 클래스 중 어떤 클래스에 속한 IP 주소인지를 알 수 있다.

<img src="https://github.com/user-attachments/assets/ace094de-df88-4e77-ab1f-26718d6d2d42" width="520"/><br/>

> #### 네트워크/브로드캐스트 주소와 예약 주소
> 호스트의 주소 공간을 모두 사용할 수 있는 것은 아니다. 호스트 주소가 전부 0인 IP 주소와 호스트 주소가 전부 1인 IP 주소는 특정 호스트를 지칭하는 데 사용될 수 없다.
> 전자는 **해당 네트워크 자체를 의미하는 주소**로 사용되고, 후자는 **브로드캐스트를 위한 주소**로 사용되기 때문이다. 가령 다음과 같은 IP 주소를 가정해 보자.
>
> <img src="https://github.com/user-attachments/assets/90771afa-b5f1-44b9-8026-a8a622880c24" width="600"/><br/>
>
> 호스트 주소가 모두 0인 '172.16.0.0'은 네트워크 자체를 지칭하기 위한 주소, 호스트 주소가 모두 1인 '172.16.255.255'는 브로드캐스트를 위한 주소로 사용된다.
> 따라서 두 주소는 호스트 주소 할당에 사용할 수 없다. 또한 특수한 목적을 위해 **예약된 IP 주소**도 있다. 자주 접할 수 있는 대표적인 예약 주소의 종류는 다음과 같다.
>
> <img src="https://github.com/user-attachments/assets/4db6e883-75b2-4f98-b366-474dfb41d5b9" width="580"/><br/>
>
> 이 중 **루프백 주소(loopback address)** 는 자기 자신을 가리키는 특별한 주소이다. 가장 일반적으로 사용되는 루프백 주소는 '127.0.0.1'로, **로컬호스트(localhost)** 라고도 부른다.
> 루프백 주소로 전송된 패킷은 자기 자신에게 되돌아오므로 자기 자신을 마치 다른 호스트인 양 간주하여 패킷을 전송할 수 있다.
>
> 인터넷 표준 공식 문서(RFC 6890)에 따르면 '예약 IP 주소의 범위 '0.0.0.0 ~ 0.255.255.255는 이 네트워크의 이 호스트(This host on this network)를 지칭하도록 예약되었다'고
> 명시되어 있는데, 가장 일반적으로 사용되는 주소는 '0.0.0.0'이다. 이 주소는 주로 호스트가 IP 주소를 할당받기 전에 임시로 사용하거나 마땅히 자신을 지칭할 IP 주소가 없을 때 사용하는 경우가 많다.

#### [클래스리스 주소 체계와 서브넷 마스크]
클래스풀 주소 체계 하에서는 클래스별 네트워크 크기가 고정되어 있었다. A, B, C 클래스의 크기가 각각 8비트, 16비트, 24비트였다.
이렇게 클래스별 네트워크 크기가 고정되어 있을 때는 고정된 크기 이외에 다른 크기의 네트워크를 구성할 수 없어 IP 주소가 낭비될 수 있다는 한계가 있다.

예를 들어 A 클래스의 네트워크 하나당 할당 가능한 호스트 IP 주소는 1,600만 개 이상이고, B 클래스 네트워크 하나당 할당 가능한 호스트 IP 주소는 6만 개 이상이다.
단일 조직에서 이 정도의 호스트가 필요한 경우는 많지 않다. 그런데 C 클래스 주소에는 호스트에게 할당할 수 있는 IP 주소가 약 200개 정도(254개)이다.
만약 300명의 직원이 사용할 컴퓨터들을 동일한 네트워크로 구성하고 싶다면 클래스풀 주소 체계 하에서는 어쩔 수 없이 B 클래스 주소를 이용해야 한다. 상당수의 IP 주소가 낭비될 우려가 있다.

이러한 문제를 해결하기 위해서는 클래스풀 주소 체계보다 더 정교하고 유동적인 네트워크 영역을 나눌 수단이 필요하다. 그래서 등장한 개념이 **클래스리스 주소 체계(classless addressing)** 이다.
말 그대로 클래스를 이용하지 않고(classless) 네트워크와 호스트를 구분하는 방식이다.

그렇다면 어떻게 클래스를 이용하지 않고 IP 주소 내 네트워크 주소와 호스트 주소를 구분할 수 있을까? 클래스리스 주소 체계에서는 네트워크와 호스트를 구분하는 수단으로 서브넷 마스크를 이용한다.
**서브넷 마스크(subnet mask)** 란 IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트이다.
그리고 **서브네트워크(subnetwork)** 는 IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합을 의미하며, **서브넷(subnet)** 이라고도 줄여 부른다.
즉, **서브넷 마스크**는 곧 서브넷을 구분(마스크(mask))하는 비트열인 셈이다.
또 이러한 서브넷 마스크를 이용해 원하는 크기로 클래스를 더 잘게 쪼개어 사용하는 것은 **서브네팅(subnetting)** 이라고 한다.

클래스풀 주소 체계에서 A 클래스의 네트워크 주소는 8비트, B 클래스의 네트워크 주소는 16비트, C 클래스의 네트워크 주소는 24비트로 이루어져 있기 때문에 A, B, C 클래스의 기본 서브넷 마스크는
다음과 같이 표현할 수 있다.

<img src="https://github.com/user-attachments/assets/58e9f612-be50-4bda-8228-3eb618fd02fa" width="470"/><br/>

서브넷 마스크와 IP 주소 간에 비트 AND 연산을 수행하면 IP 내의 네트워크 주소를 알아낼 수 있다. '192.168.200.102'라는 IP 주소와 '255.255.255.0'이라는 서브넷 마스크를 예로 들어보자.
이 둘에 대한 비트 AND 연산을 수행한 결과인 '192.168.200.0'가 바로 네트워크 주소인 셈이다.

<img src="https://github.com/user-attachments/assets/27e9b177-944e-4dc3-8852-8bc2d62ea1dc" width="400"/><br/>

> #### CIDR 표기 - 서브넷 마스크 표기법
> 서브넷 마스크를 '255.255.255.0', '255.255.255.252'와 같이 10진수로 직접 표기하는 방법도 있지만, 'IP 주소/서브넷 마스크상의 1의 개수'의 형식으로 표기하는 방법도 있다.
> 후자의 방식을 **CIDR 표기법(Classless Inter-Domain Routing notation)** 이라고 부르며, IP 주소와 서브넷 마스크를 함께 표현할 수 있는 간단한 표기로 많이 활용한다.
>
> 예를 들어보자. '192.168.20.3/30'이라고 표기한 서브넷 마스크 상에서 1이 총 30개가 있다는 것을 의미하므로 서브넷 마스크는 11111111.11111111.11111111.11111100'이 된다.
> 즉, '/30'은 '255.255.255.252'와 같은 표기이다.

<br/>

### 🍓 공인 IP 주소와 사설 IP 주소
호스트의 IP 주소는 네트워크 설정이나 명령어를 통해 확인할 수도 있고, 간단한 온라인 검색을 통해 확인할 수도 있다.
전자의 경우, 윈도우에서 'ipconfig/all'을 입력하거나 맥OS, 리눅스에서 'ifconfig' 명령어를 입력하면 IP 주소를 확인할 수 있다.

#### [윈도우: ipconfig/all]
<img src="https://github.com/user-attachments/assets/9ae162f5-4dd0-4844-85e6-c0bbd5ce0bf7" width="620"/><br/>

#### [맥OS, 리눅스: $ ifconfig]
<img src="https://github.com/user-attachments/assets/1663b167-9cbf-4ec3-8e56-0580951e3654" width="620"/><br/>

후자의 경우, 다음과 같이 구글이나 네이버 등의 검색 사이트에서 검색해 IP 주소를 확인할 수도 있다.

<img src="https://github.com/user-attachments/assets/8a74b854-c3d2-439a-9f5a-6f87092dc408" width="470"/><br/>

그런데 이 두 방식으로 확인한 IP 주소가 다른 독자가 많을 것이다. 조금 이상하다. 호스트에 할당된 IP 주소가 유일하고 고유하지 않았던 것일까?
지금까지의 IP 주소에 대한 설명에 따르면 'IP 주소는 유일하고 고유한 주소'라고 생각할 수 있다. 'IP 주소는 고갈될 수 있다', 'IP 주소는 낭비될 수 있다'고 표현했기 때문이다.
그러나 이 생각은 사실 반만 맞는 말이다. 고유한 IP 주소도 있고, 고유하지 않은 IP 주소도 있다. 그리고 이 두 종류의 IP 주소는 함께 사용되는 경우가 많다.
고유한 IP 주소는 공인 IP 주소라고 하고, 고유하지 않은 IP 주소는 사설 IP 주소라고 한다.

**공인 IP 주소(public IP address)** 는 전 세계에서 고유한 IP 주소이다. 인터넷을 검색한 네트워크 간 통신에서 사용되는 IP 주소가 바로 공인 IP 주소이다.
앞서 우리가 검색 사이트를 통해 확인했던 IP 주소가 바로 공인 IP 주소이다.
구글이나 네이버 등의 검색 사이트의 서버와 패킷을 주고받으려면 호스트가 속한 네트워크 밖에서 사용할 공인 IP 주소를 사용해야 하기 때문이다.
공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있다.

<img src="https://github.com/user-attachments/assets/dcd483f3-84e8-4ba3-a725-12466385428a" width="390"/><br/>

**사설 IP 주소(private IP address)** 는 사설 네트워크에서 사용하기 위한 IP 주소를 말한다. 사설 네트워크란 외부 네트워크에 공개되지 않은 네트워크를 말한다.
사설 IP 주소는 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당한다.

IP 주소 공간 중에서 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있다. 다음의 예약 IP 주소 범위에 속하는 IP 주소는 사설 IP 주소로 간주하기로 약속한 주소이다.

<img src="https://github.com/user-attachments/assets/c93e555e-7162-40e1-811a-35adfb6435bb" width="370"/><br/>

> 사설 IP 주소는 해당 호스트가 속한 사설 네트워크상에서만 유효한 주소이므로 얼마든지 다른 네트워크상의 사설 IP 주소와 중복될 수 있다는 점에 유의하자.

<br/>

### 🍓 IP 주소의 할당
이번에는 호스트에 IP 주소를 할당하는 방법을 알아보자. 여기에는 크게 2가지 방법이 있다. 하나는 정적 할당이고, 또 하나는 동적 할당이다.
전자는 수작업을 통해 이루어지고, 후자는 일반적으로 DHCP라는 프로토콜을 통해 이루어진다.
<br/>
#### [정적 할당]
정적 할당은 직접 수작업으로 IP 주소를 부여하는 방식으로, 정적 할당을 통해 할당된 IP 주소를 **정적 IP 주소(static IP address)** 라고 한다.
운영체제의 종류를 막론하고 IP 주소를 수동으로 설정하는 설정 혹은 명령어가 있다.

<img src="https://github.com/user-attachments/assets/68c5297a-bfa0-4302-8198-42319f3399f1" width="600"/><br/>

주목해야 할 점은 정적 IP 주소를 부여하기 위해 입력해야 하는 값이다. 다시 말해, 정적 IP 주소를 부여하기 위해 어떤 값이 필요한지에 유의해야 한다.
일반적으로 정적 IP 주소를 부여하고자 하는 IP 주소와 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등이 필요한데, 이 값은 운영체제에 관계없이 대체적으로 유사하다.

여기서 **게이트웨이(gateway)** 는 일반적으로 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단을 의미한다.
그 중에서도 **기본 게이트웨이(default gateway)** 는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로를 의미한다.
따라서 기본 게이트웨이는 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많다.
IP 할당의 맥락에서 사용되는 '게이트웨이'라는 용어는 기본 게이트웨이를 의미하므로 게이트웨이(라우터) 주소에는 기본 게이트웨이의 역할을 하는 라우터(공유기)의 주소를 적어 주면 된다.

<img src="https://github.com/user-attachments/assets/332465f5-5bbe-4b24-9fd8-5d888359b0f7" width="340"/><br/>

DNS 주소는 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소를 의미한다.
기본적으로 호스트끼리 패킷을 주고받기 위해서는 IP 주소가 사용되지만, 통신을 주고받는 모든 호스트의 IP 주소를 기억하기는 어렵다.
따라서 IP 주소에 대응되는 기억할 수 있는 문자열로 호스트를 식별할 수 있으며, 이를 도메인 네임이라고 한다. 'google.com, hanbit.co.kr, minchul.net' 등이 도메인 네임의 예시이다.
호스트가 도메인 네임을 토대로, 이에 대응되는 IP 주소를 알아내려면 <도메인 네임, IP 주소> 쌍을 저장하는 서버에 질의해야 한다. 이 서버를 네임 서버, DNS 서버라고 부른다.
DNS 서버에 대해서는 추후 '도메인 네임과 DNS'에서 다시 한번 다룬다.

<img src="https://github.com/user-attachments/assets/2ff0e0da-49b4-499b-8b5d-2ccd989befac" width="340"/><br/>

> DNS 주소에 어떤 값을 입력할지가 결정하기가 어렵다면 누구나 사용할 수 있도록 공개된 대표적인 네임 서버 주소인 '8.8.8.8', '1.1.1.1' 등을 입력하면 된다.

#### [동적 할당: DHCP]
동적 할당은 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식으로, 동적 할당을 통해 할당된 IP 주소를 **동적 IP 주소(dynamic IP address)** 라고 한다.
이 과정에서 가장 흔히 사용되는 프로토콜이 **DHCP(Dynamic Host Configuration Protocol)** 이다.
호스트에 수동으로 직접 IP 주소를 할당하지 않고도 호스트에 IP 주소가 부여되어 있다면 IP 주소가 동적으로 할당되었기 때문이다.

일상적으로 동적 IP 주소가 많이 사용되는 만큼, DHCP 또한 빈번히 사용된다. IP 주소를 동적으로 할당받고자 하는 호스트는 **DHCP 서버**와 메시지를 주고받으며 동적 IP 주소를 할당받을 수 있다.
DHCP 서버는 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받을 때 IP 주소를 할당해 주는 호스트이다. 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행한다.
동적 할당과 이를 통해 부여되는 동적 IP 주소와 관련해 기억해야 할 점은 다음과 같이 2가지가 있다.

- 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있다.
- 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있다.

DHCP로 할당받은 IP 주소는 사용할 기간(일반적으로 수 시간에서 수 일)이 정해져 있고, 사용되지 않을 경우 회수된다.
사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를 할당받는 경우 다른 IP 주소를 할당받을 수 있다.
DHCP를 통한 IP 주소의 동적 할당은 이런 점에서 'IP 주소의 임대'라고 표현하기도 한다. 참고로, IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장할 수도 있다.
이를 **임대 갱신(lease renewal)** 이라고 하며, 기본적으로 임대 갱신은 자동으로 두 차례가 수행되고, 두 번의 임대 갱신이 모두 실패하면 그때 IP 주소는 DHCP 서버로 반납된다.
<br/>
<br/>
### 🍓 IP 전송 특징의 보완: ICMP
IP는 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜이라는 특징이 있다고 설명했다. 이러한 전송 특징을 보완하기 위한 프로토콜, ICMP에 대해 알아보기 전에 우선 짚고 가야 할 것이 있다.
신뢰할 수 없는 전송과 연결을 수립하지 않는 전송이 반드시 나쁜 것일까? 그렇지 않다. IP가 신뢰성 높은 연결형 프로토콜이 아니라 신뢰할 수 없는 비연결형 프로토콜이 주된 이유는 성능에 있다.

신뢰성 높은 송수신을 하려면 유실된 패킷, 순서가 어긋난 패킷 등이 있는지를 점검해야 한다. 패킷에 대한 오류 제어를 수행해야 한다.
마찬가지로 연결형 송수신을 하려면 패킷을 주고받는 호스트 간 연결을 수립하고, 연결을 관리해야 한다. 오류 제어와 연결 수립 및 관리는 일반적으로 패킷의 '빠른' 송수신과는 배치되는 작업이다.
더 많은 시간과 대역폭, 부하가 필요하기 때문에, 이는 곧 성능상 불리하게 작용할 수 있다. 따라서 IP의 신뢰할 수 없는 비연결형 전송이라는 특징은 반드시 극복해야 할 단점이 아니다.

하지만 그럼에도 불구하고 IP의 신뢰할 수 없는 비연결형 통신이라는 특징을 보완해야 할 때가 있다. 이를 위한 방법에는 크게 2가지가 있다.
첫 번째는 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층의 프로토콜을 이용하는 것이다. 다음 절에서 학습할 TCP가 대표적이다.
신뢰할 수 있는 연결형 프로토콜인 TCP를 통해 패킷을 송수신하면 신뢰성과 연결형 통신을 보장할 수 있다.

두 번째는 네트워크 계층의 프로토콜로 ICMP를 이용하는 방법이다.
**ICMP(Internet Control Message Protocol)** 는 IP 패킷의 전송 과정에 대한 피드백 메시지(이하 ICMP 메시지)를 얻기 위해 사용하는 프로토콜로, ICMP 메시지를 통해 패킷이 상대방에게
어떻게 전송되었는지를 알려줄 수 있어 IP 전송의 결과를 엿볼 수 있다.

<img src="https://github.com/user-attachments/assets/ff09b8cc-60fd-4b88-8012-65433f0704aa" width="350"/><br/>

> 유의할 점은 ICMP가 IP의 신뢰성을 완전히 보장하지는 않는다는 점이다. ICMP 메시지 자체가 신뢰성을 완전히 보장하기 위해서는 전송 계층의 프로토콜이 필요하다.

ICMP 메시지는 크게 [1] 전송 과정에서 발생한 오류 보고와 [2] 네트워크에 대한 진단 정보(네트워크상의 정보 제공)로 유형을 나눌 수 있다.
ICMP 메시지의 종류는 매우 다양하지만, 다음 표에 제시된 메시지는 흔히 볼 수 있는 ICMP 메시지이므로 기억해 두는 것이 좋다.

<img src="https://github.com/user-attachments/assets/0287e88c-ba10-4c55-9ede-a37ea67e00d0" width="620"/><br/>

예를 들어 네트워크 장비(가령 라우터)가 패킷을 전달받았는데, 해당 패킷을 어떤 네트워크로 전송해야 할지 알 수 없을 경우 **[네트워크 도달 불가]** ICMP 메시지를 되돌려 보낸다.
또 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정되어 있어 단편화가 불가능할 경우 **[단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음]**을 나타내는 ICMP 메시지를 되돌려 보낸다.

또 다른 ICMP 메시지의 예시를 살펴보자. IP 헤더에는 패킷의 수명을 의미하는 TTL(Time To Live) 필드가 있다.
패킷은 멀리 떨어진 호스트끼리 통신할 때 여러 라우터를 거쳐 이동할 수 있는데, 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소한다.
이때 TTL 필드가 0이 되면 해당 패킷은 폐기되고, 패킷을 송신한 호스트에게 **[시간 초과(Time Exceeded)]** ICMP 메시지가 전송된다.

참고로, 패킷이 호스트 또는 라우터에 한 번 전달되는 것은 **홉(hop)** 이라고 한다. 즉, TTL 필드의 값은 홉마다 1씩 감소한다.
TTL 필드의 존재 이유는 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위함이다.

<img src="https://github.com/user-attachments/assets/cba875b6-aa34-4dad-bf07-cf8ea6fb1afe" width="550"/><br/>

ICMP 메시지는 네트워크상의 간단한 문제를 진단하고 테스트하기 위해 사용되기도 한다.
네트워크 상의 경로를 확인하는 명령어인 traceroute(윈도우 운영체제의 경우 tracert), 혹은 네트워크 상태를 점검하기 위해 패킷을 송신하는 명령어인 ping은 ICMP를 기반으로 구현된 대표적인 명령어이다.

<img src="https://github.com/user-attachments/assets/65129c19-388e-4482-bf13-ab52c4ff2f52" width="550"/><br/>
<br/>

### 🍓 IP 주소와 MAC 주소의 대응: ARP
앞서 IP의 목적과 특징을 설명하며 MAC 주소는 택배 배송 과정의 수신인과 발신인, IP 주소는 수신 주소와 발신 주소에 빗댈 수 있다고 설명했다.
택배 배달 과정에서 수신인과 발신인, 수신/발신 주소를 모두 사용하되 주소를 우선적으로 활용하듯, 패킷의 송수신 과정에서도 IP 주소와 MAC 주소를 함께 사용하지만 MAC 주소보다 IP 주소를 우선적으로
활용한다고도 했다. 이때 상대 호스트의 IP 주소는 알고, MAC 주소는 모르는 상황이 있을 수 있는데, 바로 이러한 상황에서 사용되는 프로토콜이 ARP이다.
**ARP(Address Resolution Protocol)** 는 IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜이다.

예를 들어 보자. 다음과 같이 호스트 A와 B가 동일한 네트워크에 속한 상태를 가정해 보자. 패킷을 보내는 호스트 A가 호스트 B의 IP 주소는 알고, MAC 주소는 모르는 상황이다.
통신 과정에서는 IP 주소와 MAC 주소가 함께 사용되기 때문에 호스트 A가 호스트 B의 MAC 주소를 알기 전에는 올바르게 패킷을 송신하기가 어렵다. 이럴 때 사용하는 프로토콜이 바로 ARP이다.

<img src="https://github.com/user-attachments/assets/e3e1cdbf-a371-4dff-b840-e1bd254e1098" width="300"/><br/>
<br/>

ARP 프로토콜은 동작 과정을 이해하는 것이 중요하다. ARP의 동작 과정, 즉, IP 주소를 통해 모르는 MAC 주소를 알아내는 과정은 **ARP 요청 메시지**와 **ARP 응답 메시지**를 통해 이루어진다.
ARP 요청은 브로드캐스트 메시지이다. 다시 말해, 네트워크 내에 있는 모든 호스트에게 보내는 메시지이다. ARP 요청 메시지에는 알고 싶은 MAC 주소에 대응되는 IP 주소가 포함되어 있다.
그렇기 때문에 ARP 메시지를 브로드캐스트하는 것은 마치 '이 IP 주소를 가진 호스트와 통신하고 싶은데, 이 호스트의 MAC 주소가 무엇인가요?'라고 소리치는 것과 같다.

<img src="https://github.com/user-attachments/assets/126e0fad-acc7-48e3-91af-57cb7fb01afe" width="300"/><br/>
<br/>

ARP 요청 메시지는 브로드캐스트 메시지이기 때문에 네트워크 내 모든 호스트가 이를 수신한다.
이때 호스트들은 ARP 요청 메시지에 포함된 IP 주소를 확인해 자신과 관련이 없는 IP 주소일 경우에는 무시하고, 자신의 IP 주소일 경우에는 ARP 응답 메시지를 전송한다.
ARP 응답 메시지에는 응답 메시지를 보내는 호스트의 MAC 주소가 포함되어 있다. 따라서 ARP 요청 메시지를 보낸 호스트가 ARP 응답 메시지를 수신하면 IP 주소를 통해 MAC 주소를 알아낼 수 있는 것이다.

<img src="https://github.com/user-attachments/assets/6cfc32f2-e22d-49be-b260-4260663f00b2" width="300"/><br/>
<br/>

이때, 호스트 입장에서 ARP 요청 메시지와 ARP 응답 메시지를 주고받으면서 알게 된 <IP 주소, MAC 주소> 쌍을 기억해 두는 것이 좋다.
그러지 않으면 나중에 같은 호스트에게 패킷을 보내야 할 때마다 브로드캐스트(ARP 요청) 메시지를 보내야 하기 때문이다. 그래서 ARP를 활용하는 호스트는 **ARP 테이블(ARP Table)** 이라는 정보를 유지한다.
ARP 테이블은 <IP 주소, MAC 주소>의 항목들로 구성된 표 형태의 정보이다. ARP 요청 메시지와 ARP 응답 메시지를 통해 알게 된 <IP 주소, MAC 주소> 쌍은 ARP 테이블에 추가된다.
ARP 테이블 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있다.

ARP 테이블은 간단한 명령어로 확인할 수 있다. 윈도우 명령 프롬프트(CMD)나 맥OS/리눅스 터미널에서 'arp -a'라고 입력해보자. IP 주소와 그에 대응된 MAC 주소를 볼 수 있다.

<img src="https://github.com/user-attachments/assets/56d48b62-45c4-4d78-9ab0-3b51f672c1e8" width="520"/><br/>