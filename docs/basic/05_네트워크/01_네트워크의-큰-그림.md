## [5.1] 네트워크의 큰 그림

본격적인 네트워크 학습을 시작하기 전에 알고 있어야 할 개념들이 다수 있다. 이번 절에서는 네트워크의 큰 그림을 그려 보며 네트워크를 이해하기 위한 배경지식을 학습해 보겠다.
<br/>
<br/>
### 🍓 네트워크의 기본 구조
네트워크는 노드와 간선으로 이루어진 자료구조라는 점에서 **그래프**의 형태를 띤다고 할 수 있다. 네트워크 기기가 노드이고, 네트워크 기기 간에 정보를 주고받는 유무선의 통신 매체가 간선인 셈이다.

<img src="https://github.com/user-attachments/assets/7c43ebb4-9475-4b20-8cc3-a70b888fcf2d" width="470"/><br/>

네트워크 상에서 노드와 노드 사이의 연결 구조는 **네트워크 토폴로지(network topology)** 라고 부른다.
노드가 어떻게 연결되고 배치되느냐에 따라 다음 그림과 같은 망형, 트리형, 링형 등의 유형으로 나눌 수 있다.

<img src="https://github.com/user-attachments/assets/3521803a-deaa-4824-ab6e-50ad49ff005d" width="600"/><br/>

이때 네트워크의 가장자리에 위치하면서 네트워크를 통해 주고받는 정보를 최초로 송신하고 최종 수신하는 노드를 **호스트(host)** 라고 하는데, 우리가 흔히 접하는 대부분의 네트워크 기기가 바로 호스트이다.
예를 들어 노트북의 웹 브라우저를 통해 구글 홈페이지에 접속했다면 노트북과 구글의 서버 컴퓨터가 각각 호스트로서 정보를 주고받은 것이다. 노트북과 구글의 서버 컴퓨터가 정보를 주고받는 과정은 크게 다음과 같다.

- [1] 노트북이 구글의 서버 컴퓨터에게 웹 페이지를 가져다 달라는 요청을 보낸다.
- [2] 구글의 서버 컴퓨터가 노트북에게 웹 페이지로 응답한다.

이 과정에서 노트북처럼 **요청(request)** 을 보내는 호스트를 **클라이언트(client)**, 구글의 서버 컴퓨터처럼 **응답(response)** 을 보내는 호스트를 **서버(server)** 라고 한다.
즉, 클라이언트와 서버는 주고받는 정보의 방향(요청과 응답)에 따라 부여된 역할이다.

<img src="https://github.com/user-attachments/assets/f8a8953a-ebf9-48c9-81da-980fd6a5b7a3" width="380"/><br/>

또한 네트워크를 그래프로 간주했을 때 중간에 위치한 노드, 즉 중간 노드는 가장자리에 위치한 호스트가 주고받는 정보들을 원하는 수신지까지 안정적으로 전송하는 역할을 한다.
이러한 중간 노드로써의 역할을 수행하는 여러 네트워크 장비들이 있는데, 스위치와 라우터, 공유기 등이 해당된다.
<br/>

#### [LAN과 WAN]
네트워크는 그래프의 형태를 띄고 있다고 했지만, 그렇다고 해서 전 세계에 하나의 네트워크만 존재하는 것은 아니다. 여러 개의 네트워크로 나뉘어질 수 있기 때문이다.
네트워크는 규모에 따라 LAN과 WAN으로 나뉜다.

근거리 네트워크를 의미하는 **LAN(Local Area Network)** 은 이름 그대로 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크를 말한다.
집이나 사무실에 있는 공유기를 통해 모든 네트워크 기기가 통신하고 있다면 LAN이 공유기를 기준으로 구축되었다고 할 수 있다.
해당 공유기와 연결된 네트워크 기기들은 모두 같은 네트워크(LAN)에 속해 있다고 인식한다. 하지만 모든 네트워크 기기들이 같은 네트워크(LAN)에서만 정보를 주고받는 것은 아니다. LAN 간의 통신도 빈번하다.

원거리 네트워크를 의미하는 **WAN(Wide Area Network)** 을 통해 LAN 간 통신이 이루어진다. WAN이 인터넷을 가능하게 만드는 네트워크라고 할 수 있다.
WAN은 일반적으로 **ISP(Internet Service Provider)** 라는 인터넷 서비스 업체가 구축하고 관리한다. 대표적인 국내 ISP 업체로는 KT, LG유플러스, SK브로드밴드가 있다.

<img src="https://github.com/user-attachments/assets/f3afa2ca-85b4-476e-953a-a4254c55b27c" width="420"/>
<br/>

#### [패킷 교환 네트워크]
서로 다른 네트워크에 있는 두 호스트가 유무선의 통신 매체를 통해 100GB의 파일을 주고받는 경우를 가정해보자. 이때 호스트는 유무선의 통신 매체를 통해 100GB의 파일을 한 번에 전송할 수 있을까?
그렇지 않다. 네트워크를 통해 주고받는 데이터는 한 번에 송수신되지 않고, 여러 데이터로 쪼개져서 송수신된다. 이렇게 네트워크를 통해 송수신되는 데이터의 단위를 **패킷(packet)** 이라고 한다.
오늘날의 네트워크는 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하며 패킷을 주고받는 '패킷 교환 네트워크'가 대부분이다.

하나의 패킷은 **페이로드(payload)** 와 **헤더(header)** 로 구성되어 있으며, 때로는 **트레일러(trailer)** 라는 정보가 포함되기도 한다.
페이로드는 패킷에서 송수신하고자 하는 데이터이고, 헤더와 트레일러는 패킷에 추가되는 부가 정보이다.
페이로드가 택배(패킷)를 통해 송수신하고자 하는 물품이라면, 헤더와 트레일러는 택배 앞뒤로 붙이는 송장(부가 정보)과 같다.
<br/><br/>
<img src="https://github.com/user-attachments/assets/2368c946-8ccd-4fc5-bbdc-20fca53bd687" width="310"/>
<br/>

#### [주소의 개념과 전송 방식]
네트워크상의 두 호스트가 패킷을 주고받는 상황을 가정해 보자. 올바르게 정보를 주고받기 위해서는 서로를 특정할 수 있는 정보, 즉 주소가 필요하다.
**주소(address)** 는 패킷의 헤더에 명시되는 정보로, 네트워크에서 사용되는 대표적인 주소로는 IP 주소와 MAC 주소가 있다.

주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 보낼 수 있는데, 가령 수신지를 특정 호스트 하나로 지정할 수 있고, 네트워크 내 모든 호스트로 지정할 수도 있다.
송신지와 수신지가 일대일로 메시지를 주고받는 전자의 전송 방식을 **유니캐스트(unicast)** 라고 하고, 네트워크상의 모든 호스트에게 메시지를 전송하는 후자의 전송 방식을 **브로드캐스트(broadcast)**
라고 한다. 이때 브로드캐스트가 전송되는 범위를 **브로드캐스트 도메인(broadcase domain)** 이라고 하며, 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우에는 같은 LAN에 속해 있다고 간주한다.

<img src="https://github.com/user-attachments/assets/2ca73912-8329-4bbb-8b19-365a4d2231ff" width="400"/>
<br/>

이 밖에도 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 **멀티캐스트(multicast)**, 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 **애니캐스트(anycast)** 등
다양한 송수신 방식들이 있지만, 유니캐스트와 브로드캐스트가 가장 자주 언급되므로 기억해 두기 바란다.
<br/>
<br/>
### 🍓 두 호스트가 패킷을 주고받는 과정
네트워크 내의 호스트는 서로가 주고받을 내용(패킷)을 이해할 수 있어야 하고, 이를 올바르게 주고받을 수 있어야 한다.
이번에는 호스트가 서로 주고받는 정보를 이해하기 위한 규칙인 프로토콜과 네트워크 참조 모델의 개념을 알아보고, 두 호스트가 패킷을 주고받는 과정 전반에 대해 이해해보자.
<br/>
#### [프로토콜]
서로의 주소를 알고 있는 두 호스트가 패킷을 주고받는 상황을 생각해보자. 패킷을 주고받는 두 호스트가 서로 다른 LAN에 속해 있어, 서로가 주고받는 패킷이 네트워크 장비를 거친다고 가정해보자.
당연하게도 두 호스트가 주고받는 패킷 속 내용은 서로가 이해할 수 있어야 한다. 호스트뿐만 아니라 패킷이 거쳐 갈 네트워크 장비 역시 패킷의 내용을 이해할 수 있어야 한다.
이를 위해 정한 규칙이 바로 프로토콜이다.

**프로토콜(protocol)** 은 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법을 말한다.
패킷을 주고받는 호스트와 네트워크 장비들이 서로 주고받는 정보를 이해하려면 같은 프로토콜을 이해해야 하고, 같은 프로토콜로 통신해야 한다.
이런 점에서 프로토콜은 흔히 네트워크의 언어와 같다고 표현한다(다만, 일상 속 언어와 달리 네트워크에서는 여러 프로토콜을 함께 사용한다).
네트워크 프로토콜의 종류는 매우 다양하다. 하지만 개발자가 기본적으로 알아야 할 프로토콜의 종류는 다음과 같이 어느 정도 정해져 있으므로 이번 장에서는 주요 프로토콜을 중심으로 살펴보겠다.

<img src="https://github.com/user-attachments/assets/ddadf167-c6ae-422d-bb77-53e426761014" width="570"/>
<br/>
<br/>

중요한 점은 프로토콜마다 **목적**과 **특징**이 다르다는 점이다. 프로토콜은 아무런 이유 없이 만들어지고 사용되지 않는다. 프로토콜이 존재하는 이유, 즉 목적이 있다.
마찬가지로, 유사한 목적을 지닌 프로토콜들이 존재할 경우 각 프로토콜을 구분 짓는 특징이 존재한다.

예를 들어 IP는 네트워크 간의 **주소를 지정**한다는 목적을 지닌 프로토콜이고, ARP는 **IP 주소와 MAC 주소를 대응**시킨다는 목적을 지닌 프로토콜이다.
또 HTTPS는 보안상 HTTP에 비해 **안전**하며, TCP는 UDP에 비해 **신뢰성**이 높다는 특징을 갖고 있다.
이처럼 프로토콜마다 목적과 특징이 다르므로 프로토콜을 학습할 때는 각 프로토콜의 목적과 특징에 집중해 살펴보는 것이 좋다.

마찬가지로, 각각의 목적과 특징이 다른 프로토콜로 구성된 '패킷의 내용' 또한 달라질 수 있다.
패킷은 패킷을 구성하는 프로토콜의 목적과 특징에 따라 다음과 같이 그에 걸맞는 패킷 헤더를 가진다. 따라서 각 프로토콜의 목적과 특징을 이해하기 위해서는 프로토콜의 패킷 헤더를 분석해 보는 것이 좋다.
이번 장에서 우리는 앞서 언급한 주요 프로토콜의 패킷 헤더도 분석해 볼 예정이다.

<img src="https://github.com/user-attachments/assets/ce198e1c-ad86-47bf-a19c-9ce97e4ef398" width="570"/>
<br/>

#### [네트워크 참조 모델]
호스트 간에 패킷을 주고받는 과정은 택배를 주고받는 과정과 비슷하다. 택배를 주고받는 상황을 떠올려보면, 택배를 주고받는 과정에는 정형화된 순서가 있다.
다음 그림처럼 계층적으로 표현할 수 있다. 택배를 보내는 과정은 곧 택배를 받는 과정의 반대라고 할 수 있다. 네트워크의 경우도 이와 크게 다르지 않다.

<img src="https://github.com/user-attachments/assets/62bdc40e-7824-47b6-9761-0539467349ec" width="570"/>
<br/>

패킷을 주고받는 과정에도 정형화된 순서가 있고, 계층적으로 표현할 수 있다는 것이다.
이렇게 통신이 이루어지는 단계를 계층적으로 표현한 것을 **네트워크 참조 모델(network reference model)** 이라고 한다.
패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들이게 되는 것이다.

<img src="https://github.com/user-attachments/assets/0052ffeb-1c37-47ef-b2f4-30f1264eb700" width="570"/>
<br/>

> 제시된 그림은 패킷 송수신 과정을 간단하게 표현한 예시이므로 특별히 암기할 필요는 없다.

네트워크 참조 모델에서 각각의 계층이 하는 일은 명확하게 정해져 있다. 따라서 계층별 목적에 맞는 프로토콜과 장비를 구성하면 네트워크의 구성과 설계, 문제의 진단과 해결이 용이해진다.
그럼 대표적인 네트워크 참조 모델인 OSI 모델과 TCP/IP 모델에 대해 알아보자.

### ▶︎ OSI 모델
**OSI 모델**은 국제 표준화 기구(ISO, International Organization for Standardization)에서 만든 네트워크 참조 모델로, 통신 단계를 7개의 계층으로 나눠 OSI 계층이라고 부른다.
OSI 모델은 다음과 같이 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성되어 있다. 하나씩 좀 더 자세히 알아보자.

<img src="https://github.com/user-attachments/assets/579b1f4a-4152-4bc1-9c89-afaacca80393" width="230"/>
<br/>

#### [1] 물리 계층
**물리 계층(physical layer)** 은 가장 최하위 계층으로, 비트 신호를 주고받는 계층이다.
컴퓨터는 0과 1만을 이해할 수 있기 때문에 네트워크를 통해 주고받는 정보 또한 0과 1로 이루어진 신호로 구성된다. 물리 계층은 이러한 신호를 유무선 통신 매체를 통해 운반하는 계층이다.

#### [2] 데이터 링크 계층
**데이터 링크 계층(data link layer)** 은 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층이다.
이를 위해 같은 네트워크에 속한 호스트를 식별할 수 있는 주소(MAC 주소)를 사용하고, 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인하기도 한다.
짐작할 수 있듯, 물리 계층과 데이터 링크 계층은 서로 밀접하게 연관된 계층이며, 하드웨어와 밀접하게 맞닿아 있는 계층이다.
다음 절에서 물리 계층과 데이터 링크 계층의 개념과 기반 기술, 관련한 네트워크 장비에 대해 좀 더 자세히 정리해 보겠다.

#### [3] 네트워크 계층
**네트워크 계층(network layer)** 은 네트워크 간 통신을 가능하게 하는 계층이다.
데이터 링크 계층이 기본적으로 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위해 필요한 계층이라면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층이다.
따라서 네트워크 간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소)가 필요하다. 네트워크 계층에서 대표적으로 사용되는 프로토콜이 바로 IP이다.

#### [4] 전송 계층
네트워크를 통해 송수신되는 패킷은 전송 도중에 유실될 때도 있고, 순서가 뒤바뀔 때도 있다. **전송 계층(transport layer)** 은 이러한 상황에 대비해 신뢰성 있는 전송을 가능하게 하는 계층이다.
또한 **포트(port)** 라는 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층이기도 하다. 전송 계층에 속한 대표적인 프로토콜에는 TCP와 UDP가 있다.

#### [5] 세션 계층
**세션 계층(session layer)** 은 응용 프로그램 간의 연결 상태를 의미하는 **세션(session)** 을 관리하기 위한 계층이다.
즉, 응용 프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는 역할을 한다.

#### [6] 표현 계층
**표현 계층(presentation layer)** 은 마치 번역가와 같은 역할을 하는 계층으로, 인코딩과 압축, 암호화와 같은 작업을 수행한다.
세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분짓지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.

#### [7] 응용 계층
마지막으로 **응용 계층(application layer)** 은 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층으로, 중요한 프로토콜들이 다수 포함되어 있다.
응용 계층에 속한 대표적인 프로토콜에는 HTTP, HTTPS, DNS 등이 있다.
<br/>
### ▶︎ TCP/IP 모델
TCP/IP 4계층이라고도 불리는 **TCP/IP 모델**은 네트워크 액세스 계층과 인터넷 계층, 전송 계층, 응용 계층으로 구성되어 있다.
OSI 모델은 주로 네트워크의 이론적 기술을 목적으로 사용하는 반면, TCP/IP 모델은 구현과 프로토콜에 중점을 둔 네트워크 참조 모델이다.

<img src="https://github.com/user-attachments/assets/5348c4ef-2b1e-4e93-998b-dde32ec47ea8" width="230"/>
<br/>
<br/>
OSI 모델과 TCP/IP 모델이 만들어진 목적이 다른 만큼, 두 모델에 대한 직접적이고 엄밀한 비교는 어려울 수 있다.
그러나 계층별로 수행하는 역할을 기준으로 OSI 모델과 TCP/P 모델의 계층을 비교하면 어렵지 않게 이해할 수 있다.

TCP/IP 모델의 최하위 계층인 **[1] 네트워크 액세스 계층(network access layer)** 은 **링크 계층(link layer)** 또는 **네트워크 인터페이스 계층(network interface layer)**
이라고도 부르는데, 이는 OSI 모델의 데이터 링크 계층과 유사하다(TCP/IP 모델에는 OSI 모델에서의 물리 계층에 해당하는 개념이 없다고 보는 견해도 있다).
두 번째 계층인 **[2] 인터넷 계층(internet layer)** 은 OSI 모델의 네트워크 계층과 유사하며, **[3] 전송 계층(transport layer)** 은 OSI 모델의 전송 계층,
**[4] 응용 계층(application layer)** 은 OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사하다.

여기서는 (다른 여러 전공 서적에서 서술하는 방식을 차용하여)TCP/IP 모델에 물리 계층을 추가한 확장된 모델로써 네트워크를 설명한다.
유무선 통신 매체를 통해 신호를 주고받는 '물리계층'부터 사용자 및 사용자 프로그램과 가장 가까이 맞닿아 있는 '응용 계층'까지 점차 계층을 올라가며 학습을 이어 갈 예정이다.

<img src="https://github.com/user-attachments/assets/3c0eeb38-9ccc-48f9-8412-28bc0396ea7e" width="570"/>
<br/>

#### [캡슐화와 역캡슐화]
프로토콜과 네트워크 참조 모델을 토대로 이뤄지는 패킷의 송수신 과정 중 송신 과정에서는 캡슐화가 이루어지고, 수신 과정에서는 역캡슐화가 이루어진다.
이 캡슐화와 역캡슐화를 이해하려면 앞서 학습한 **네트워크 계층 구조를 통한 송수신**과 **패킷의 구조**를 상기해 보아야 한다.

- 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들인다.
- 네트워크 계층 구조를 이용하면 프로토콜을 계층별로 구성할 수 있다.
- 하나의 패킷은 헤더와 페이로드(때로는 트레일러까지)를 포함하며, 프로토콜의 목적과 특징에 따라 헤더의 내용은 달라질 수 있다.

즉, 각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로
전달한다. 상위 계층의 패킷이 하위 계층의 페이로드로 간주되는 것이다. **캡슐화(encapsulation)** 란 이렇게 송신 과정에서 헤더(및 트레일러)를 추가해 나가는 과정을 의미한다.
반대로, **역캡슐화(decapsulation)** 란 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정을 의미한다.

이때 유의할 점은 각 계층에서 주고받는 패킷(메시지)을 지칭하는 이름이 다르다는 것이다. 다음과 같이 OSI 모델을 기준으로 계층마다 패킷을 부르는 이름이 다르다.
언급된 용어가 많지만 모두 자주 사용하는 용어이므로 익혀 두는 것이 좋다.

<img src="https://github.com/user-attachments/assets/6e096ad3-29e2-44d1-8d43-9d8bc9589c5f" width="650"/>
<br/>

요컨대, 네트워크 계층 구조상 캡슐화와 역캡슐화 과정은 다음과 같이 표현할 수 있다.

<img src="https://github.com/user-attachments/assets/aca9532e-dc85-4496-820e-05bb9ab6df30" width="680"/>
<br/>

실제 캡슐화와 역캡슐화가 어떻게 이루어지는지 직접 살펴보자. 다음 그림은 실제 네트워크를 통해 주고받는 패킷을 나타낸다. 오른쪽은 실제 데이터이고, 왼쪽은 같은 내용을 보기 좋게 표현한 것이다.

<img src="https://github.com/user-attachments/assets/fa7e7124-3a10-4cd0-aaf2-42c8b549d9e8" width="750"/>
<br/>

> 와이어샤크(wireshark)라는 패킷 캡처 프로그램을 이용한 것이다.

다음은 각각 차례대로 데이터 링크 계층과 네트워크 계층의 헤더를 나타내고 있다.
첫 번째 그림 오른쪽의 'f2 00 00'부터 '01 08 00'까지가 데이터 링크 계층의 헤더이고, 두 번째 그림 오른쪽의 '45 00 01'부터 '0a 0a 01'까지가 네트워크 계층의 헤더이다.
네트워크 계층의 헤더가 데이터 링크 계층의 헤더 다음으로 덧붙여 있음을 알 수 있다.

<img src="https://github.com/user-attachments/assets/02b8b5f5-e4fa-4056-b4a3-549da1fc1fbd" width="750"/>
<br/>

<img src="https://github.com/user-attachments/assets/8cd9ed8b-3658-4677-b65f-a09f8eb9f251" width="750"/>
<br/>

다음의 'fe 81 00'부터 'cb 00 00'까지는 전송 계층의 헤더로, 역시 네트워크 계층에서 덧붙인 헤더 다음으로 덧붙여 있음을 알 수 있다.

<img src="https://github.com/user-attachments/assets/01765e64-c169-4555-aa90-4a923dab4034" width="750"/>
<br/>

다음은 응용 계층에서 붙여진 데이터로, 실제 송수신하고자 하는 데이터는 이 부분에 포함되어 있다.

<img src="https://github.com/user-attachments/assets/475598e0-6c80-4653-81ab-2cf76abf6efc" width="750"/><br/>
<br/>

### 🍓 네트워크 지도 그리기
여기까지 학습한 배경지식을 바탕으로 이번 장에서 정리할 네트워크에 대한 지도를 그려 보겠다. 기본적으로는 통신의 과정을 계층적으로 표현한 네트워크 참조 모델을 최하위 계층부터 최상위 계층까지 정리할 예정이다.

가장 먼저, 2절에서는 물리 계층과 데이터 링크 계층에 대해 알아볼텐데, 물리 계층과 데이터 링크 계층을 하나의 절에서 함께 학습하는 이유는 두 계층이 오늘날 네트워크 환경에서 공통된 기술을 기반으로 구현되기 때문이다.
두 계층의 기반이 되는 공통된 기술인 **이더넷**은 2절에서 다룬다.

물리 계층과 관련해서는 유무선 통신 매체에 대해 알아보고, 데이터 링크 계층과 관련해서는 주고받는 프레임의 형태를 학습하면서 많은 주요 네트워크 장비들을 접하게 될텐데, 대표적인 네트워크 장비로는
네트워크와의 연결 다리 역할을 하는 하드웨어인 NIC와 물리 계층의 대표적인 하드웨어인 허브, 데이터 링크 계층의 대표적인 하드웨어인 스위치가 있다.

<img src="https://github.com/user-attachments/assets/c1bc5dcc-c606-4abf-b8ea-2b1f629639f1" width="310"/><br/>
<br/>

3절에서는 네트워크 계층을 다룬다. 네트워크 계층에서 가장 중요한 프로토콜은 IP이므로 IP가 어떤 목적과 특징이 있는지, IP 기반 주소 체계인 IP 주소에 대해 자세히 정리해 볼 것이다.
또한 IP의 전송 특징을 보완하는 ICMP, ARP라는 프로토콜도 함께 학습할 예정이다.

<img src="https://github.com/user-attachments/assets/7f600bd4-b804-47f6-bb1a-9ff520369607" width="500"/><br/>
<br/>

> 참고로, DHCP는 엄밀히 말해 응용 계층의 프로토콜이다. 하지만 네트워크 계층과 깊은 연관이 있는 프로토콜이므로 3절에서 다룬다.

4절에서는 전송 계층에 대해 다룬다. 전송 계층에서 가장 중요한 프로토콜은 TCP와 UDP이므로 TCP와 UDP가 어떤 목적과 전송 특징이 있는지 정리해 볼 것이다.
참고로, TCP와 UDP는 모두 중요한 개념이지만, TCP에 학습할 내용이 더 많다. TCP는 UDP가 제공하지 않는 연결 수립 기능, 오류・흐름・혼잡 제어 기능, 상태 관리 기능 등을 제공하기 때문이다.
따라서 4절에서는 이러한 TCP의 주요 기능들을 추가적으로 학습한다.

<img src="https://github.com/user-attachments/assets/eec371bd-416e-4e4e-b0d8-905bdf164091" width="320"/><br/>
<br/>

개발자 입장에서 가장 자주 접하게 될 계층은 응용 계층이 될 것이므로 5절과 6절, 두 절에 걸쳐 다룰 예정이다. 응용 계층에는 다양한 프로토콜이 있지만, 가장 중요한 프로토콜은 단연 HTTP이다.
다만, HTTP를 온전히 이해하기 위해 사전에 알고 있어야 하는 개념이 있다. 바로 DNS와 URI/URL이다. 따라서 두 개념을 먼저 정리하고, HTTP의 목적과 특징에 대해 학습할 예정이다.
HTTP는 너무 중요한 프로토콜이기 때문에 HTTP로 주고받는 메시지 구조를 자세히 분석해 보고, 이 과정에서 HTTP의 메소드와 상태 코드, 헤더란 무엇이며, 어떠한 종류가 있는지 이해해 보겠다.

또한 HTTP를 기반으로 하는 대표적인 기술인 쿠키, 캐시, 콘텐츠 협상을 비롯해, 안전하게 HTTP 메시지를 송수신할 수 있도록 하는 프로토콜인 HTTPS와 그 프로토콜의 원리가 되는 프로토콜인
TLS/SSL에 대해서도 알아볼 예정이다.

<img src="https://github.com/user-attachments/assets/dd2c228b-46ce-4e89-8ab0-b7abd319ef8e" width="370"/><br/>
<br/>

이렇게 네트워크 참조 모델을 살펴본 다음에는 한 발 더 나아간다. 여러 대의 서버로 다중화되어 있는 환경을 상정하고, 클라이언트와 서버 사이에 위치하는 중간 서버에 대해 알아볼 것이다.
이와 관련하여 포워드 프록시와 리버스 프록시를 학습하고, 네트워크의 안정성은 어떻게 수식화할 수 있는지(가용성), 가용성을 높이기 위한 방법인 로드 밸런싱과 스케일링이 무엇인지도 알아볼 것이다.

<img src="https://github.com/user-attachments/assets/2ca6229f-167e-449b-aab5-a2f7cd129a26" width="450"/><br/>
<br/>

여기까지가 이번 장을 통해 학습할 네트워크 지식의 지도이다. 컴퓨터 네트워크 지식의 큰 그림을 그려 본 것이다. 그럼, 물리 계층과 데이터링크 계층부터 차근차근 학습해 보도록 한다.